created: 20230824070828538
modified: 20230824085611371
tags: linux kernel
title: LKD 第4章 进程调度
type: text/vnd.tiddlywiki

进程调度的目标就是造成一个所有进程公平运行的理想世界。因为这个理想不能达到，CPU有限，那么就需要调度尽可能达到公平。

!! 4.1 多任务分为抢占式多任务和非抢占式多任务

非抢占式多任务中进程需要自觉让出CPU（yielding），这几乎不可能。所以现代的os几乎都是抢占式。

!! 4.2 O(1)到CFS的演变历史，看书即可

!! 4.3 策略

!!! 4.3.1 I/O消耗型和处理器消耗型

前者大部分时间用于提交I/O请求或者等待I/O请求，后者大多时间用于执行代码。当然兼有类型的进程也是存在的。调度器需要在这两者之间寻找平衡：进程相应迅速（相应时间短）和最大系统利用率（高吞吐量）。

!!! 4.3.2 进程优先级：Linux有两种不同的优先级范围

第一种是nice值，越大意味着优先级更低。这个概念在不同Unix系统中有所差异。Mac OS X中nice值代表分配时间片的绝对值，而在Linux中代表时间片比例。可以通过ps-el中NI列查看nice值。

第二种是实时优先级，给实时进程用的，所以与nice值互不相交。

!! 4.4 Linux调度算法

!!! 4.4.1 Linux支持同时存在多个调度器类

调度器类之间的选择是先紧着高优先级的调度类，然后才是低优先级调度类（参见4.5.3代码）。其中SCHED_NORMAL是针对普通进程的调度类，CFS算法在kernel/sched_fair.c中。

!!! 4.4.2 4.4.3

花费大量篇幅讲了为什么需要nice值代表处理器的使用比，而非时间片绝对值。

由于切换消耗的存在，CFS保证每个进程时间片底线（最小粒度），通常是1ms。这是一个折中选择（P42）。

!! 4.5 Linux调度的实现

!!! 4.5.1 时间记账

CFS使用struct_sched_entity（位于<linux/sched.h>）追踪进程运行记账，其作为名为se的成员变量，嵌入在struct task_struct中。

!!! 4.5.2 虚拟实时（vruntime）

vruntime即虚拟运行时间，用于记录一个程序到底运行了多长时间以及它还应该再运行多久，其计算是经过所有可运行进程总数标准化的（加权的）。参见kernel/sched_fair.c中update_curr()，以及其调用的_ _update_curr()。其中cfs_rq是runtime queue的缩写，CFS的调度器就绪队列，curr指向当前正在cpu上运行的task的调度实体。update_curr()由系统定时器周期性调用，所以vruntime可以准确测量给定进程运行时间。

!!! 4.5.2 进程选择

CFS需要选择具有最小vruntime的任务，原理是红黑树，vruntime作为键。具体代码指引参见书P45-48。

挑选任务时总是选择vruntime最小，也就是leftmost的那个。作为优化，该值在插入或删除时被缓存了起来。

!!! 4.5.3 调度器入口 schedule() in kernel/sched.c。什么时候调用这个函数呢？看一眼4.5.4的第一句话。

这个函数调用pick_next_task()，其核心在第二个循环中。他获得高优先级调度类的进程后直接返回，所以下次调用该函数时，仍然会返回高优先级调度类的进程，直到该调度类没有进程了，才会到轮到低优先级的调度类。循环之前的是优化，如果进程数==CFS进程数，那就直接调用CFS进程的pick_next_task。优化是因为大多数进程都是普通进程。

!!! 4.5.4 睡眠与唤醒

休眠可能是因为I/O，这时进程会把自己标记为休眠状态，从可执行rbtree中移出，放入等待队列（链表），然后调用schedule()执行其他进程。休眠等待事件的发生，事件可能是I/O或者硬件，会唤醒进程，将进程设置为可执行状态，从等待队列移到rbtree中。

!!!! 1. 等待队列 wake_queue_head_t

这里的竞争条件留作TODO吧，第10章看完再讨论。这部分代码自己看书。

!!!! 2. 唤醒 wake_up()

会唤醒指定等待队列上所有进程。其调用try_to_wake_up()，设置TASK_RUNNING，调用enqueue_task()加入rbtree，并设置need_resched标志。

等待条件达成的代码应该负责调用wake_up()，比如磁盘数据到来时的VFS。

!! 4.6 抢占和上下文切换

asm相关的，回忆xv6的swtch.S。

Linux中为context_switch()，在新进程被选出准备投入运行时，schedule()会调用本函数。分别是虚拟内存切换的switch_mm()和处理器状态（栈和寄存器）的switch_to()。

内核什么时候应该调用schedule()呢？除了用户自发的让步，还需要need_resched标志表示是否需要重新执行一次调度。懒得抄了，参见P52表4-1和上面那一段。

!!! 4.6.1 用户抢占

就是返回用户空间时有need_resched标志设置的话就选一个别的进程运行。

!!! 4.6.2 内核抢占

Linux不同于其他大多数Unix，它支持内核抢占。如果没有内核抢占，一个内核任务会执行到底，也就是''内核各任务间就不会抢占''。

什么时候可以内核抢占呢？没有持有锁的时候。试想A持有锁却被B抢占，而B正获取这个锁。这些等第9章深入讨论。

!! 4.7 实时调度

懒得写了。

!! 4.8 调度相关的系统调用

这些原来是可以设置的，不过普通进程不能设置负的nice值，超级用户可以。绑定处理器也可以设置。用户也可以主动放弃处理器，通过调用sched_yield()。

看完书再去看https://www.zhihu.com/question/35484429/answer/62964898，能够有一个历史认知。